#读写文件
1、fopen()，fwrite() 以及 fclose()
2、file_get_content、file_put_content

#dirname() 函数返回路径中的目录部分。

#文件上传
##获取上传的文件信息
$_FILES(内涵疑似临时存储的文件参数tmp_name)

#uniqid()函数基于以微秒计的当前时间,生成一个唯一的 ID

#fastcgi_finish_request(http://www.laruence.com/2011/04/13/1991.html) 浏览器执行一些响应时间长的请求的时候，可以使用这个方法结束请求，然后在后台据需运行。

#php报错日志
/var/log/php-fpm/www-error.log

#加载mysql拓展
extension_dir = "/usr/lib64/php/modules"
extension= mysqli.so

#加载pdo拓展
pdo_mysql.default_socket = /var/lib/mysql/mysql.sock

#配置php.ini文件，关闭错误提示，打开错误日志，设置错误日志路径
打开php.ini配置文件；

找到display_errors = On；修改为：display_errors = Off；

找到log_errors = Off；修改为：log_errors = On；

开启日志记录：error_log = "\xampp\apache\logs\php_error.log"，具体路径可自行设置

保存修改，重启apache即可。

#微信网页端上传到微信服务器
mall\Client\modules\Vote\views\reg\enroll.html
下载到本地
\mall\Client\modules\Vote\controllers\Reg.php

#文件之间建立软链接
window：
mklink /d D:\web\mall\Client\library D:\web\mall\Service\library
后面为文件实体路径
linux：
ln -s /bin/less /usr/local/bin/less

在初始化远程仓库时最好使用 git --bare init   而不要使用：git init
   如果使用了git init初始化，则远程仓库的目录下，也包含work tree，当本地仓库向远程仓库push时,   如果远程仓库正在push的分支上（如果当时不在push的分支，就没有问题）, 那么push后的结果不会反应在work tree上,  也即在远程仓库的目录下对应的文件还是之前的内容，必须得使用git reset --hard才能看到push后的内容.


 #更新数据库mysql中user表用户密码
 eg:update user set `Password` =PASSWORD('1234')

 #导入excel数据
 转为csv格式
        $base_path = __dir__;
       $filename = 'account.csv';
       if (!file_exists($base_path .  '/'.$filename)) {
           print_r('文件不存在');exit;
       }
       $file = fopen($base_path .  '/'.$filename,'r');
       while ($data = fgetcsv($file)) { //每次读取CSV里面的一行内容
           //print_r($data); //此为一个数组，要获得每一个数据，访问数组下标即可
           try {
               $data = eval('return '.iconv('gbk','utf-8',var_export($data,true)).';');
               $data = array($data[0], $data[1], $data[2], $data[3], $data[4]);
           } catch (Exception $e) {
               $data = array();
           }
           $content[] = $data;
       }
       echo "<pre>";
       $content = array_map(function($value){return array_filter($value);}, $content);
       $content = array_values(array_filter($content));
       $sql = array();

#盗链
图片链接被其他网站盗用

#dns劫持
域名->dns服务器->解析成ip地址->访问ip对应的服务器


#curl 请求
 function httpsPost($url, $data = null)
{
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $url);
    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);
    if (!empty($data)) {
        curl_setopt($curl, CURLOPT_POST, 1);
        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
    }

    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
    $output = curl_exec($curl);
    curl_close($curl);

    return $output;
}

#整个文件读入一个字符串中(可取线上资源)
file_get_contents()

#把一个字符串写入文件中
file_put_contents()

#集成的微信接口 示例
library/WeiXin.php(mall)

#微信API管理接口
controller/WeiXin.php(mall)

#页面渲染
//$charset 不能是UTF8 否则IE下会乱码
function fetch($templateFile = '', $tvar = array(), $charset = 'utf-8', $contentType = 'text/html', $display = false)
{
    //注入全局变量ts
    global $ts;
    $tvar['ts'] = $ts;
    //$GLOBALS['_viewStartTime'] = microtime(TRUE);

    if (null === $templateFile)
        // 使用null参数作为模版名直接返回不做任何输出
        return;

    if (empty($charset)) $charset = C('DEFAULT_CHARSET');

    // 网页字符编码
    header("Content-Type:" . $contentType . "; charset=" . $charset);

    header("Cache-control: private");  //支持页面回跳

    //页面缓存
    ob_start();
    ob_implicit_flush(0);

    // 模版名为空.
    if ('' == $templateFile) {
        $templateFile = APP_TPL_PATH . '/' . MODULE_NAME . '/' . ACTION_NAME . '.html';

        // 模版名为ACTION_NAME
    } elseif (file_exists(APP_TPL_PATH . '/' . MODULE_NAME . '/' . $templateFile . '.html')) {
        $templateFile = APP_TPL_PATH . '/' . MODULE_NAME . '/' . $templateFile . '.html';

        // 模版是绝对路径
    } elseif (file_exists($templateFile)) {

        // 模版不存在
    } else {
        throw_exception(L('_TEMPLATE_NOT_EXIST_') . '[' . $templateFile . ']');
    }

    //模版缓存文件
    $templateCacheFile = C('TMPL_CACHE_PATH') . '/' . APP_NAME . '_' . tsmd5($templateFile) . '.php';

    //载入模版缓存
    if (!$ts['_debug'] && file_exists($templateCacheFile)) {
        //if(1==2){ //TODO  开发
        extract($tvar, EXTR_OVERWRITE);

        //载入模版缓存文件
        include $templateCacheFile;

        //重新编译
    } else {

        tshook('tpl_compile', array('templateFile', $templateFile));

        // 缓存无效 重新编译
        tsload(CORE_LIB_PATH . '/Template.class.php');
        tsload(CORE_LIB_PATH . '/TagLib.class.php');
        tsload(CORE_LIB_PATH . '/TagLib/TagLibCx.class.php');

        $tpl = Template::getInstance();
        // 编译并加载模板文件
        $tpl->load($templateFile, $tvar, $charset);
    }

    // 获取并清空缓存
    $content = ob_get_clean();

    // 模板内容替换
    $replace = array(
        '__ROOT__' => SITE_URL,           // 当前网站地址
        '__UPLOAD__' => UPLOAD_URL,         // 上传文件地址
        //'__PUBLIC__'    =>  PUBLIC_URL,       // 公共静态地址
        '__PUBLIC__' => THEME_PUBLIC_URL,   // 公共静态地址
        '__THEME__' => THEME_PUBLIC_URL,   // 主题静态地址
        '__THEMENEW__' => THEME_PUBLIC_NEW_URL,   // 新版主题静态地址
        '__THEMEW3G__' => THEME_PUBLIC_W3G_URL,   // 3G版文件静态地址
        '__APP__' => APP_PUBLIC_URL,     // 应用静态地址
        '__URL__' => __ROOT__ . '/index.php?app=' . APP_NAME . '&mod=' . MODULE_NAME,
    );

    if (C('TOKEN_ON')) {
        if (strpos($content, '{__TOKEN__}')) {
            // 指定表单令牌隐藏域位置
            $replace['{__TOKEN__}'] = $this->buildFormToken();
        } elseif (strpos($content, '{__NOTOKEN__}')) {
            // 标记为不需要令牌验证
            $replace['{__NOTOKEN__}'] = '';
        } elseif (preg_match('/<\/form(\s*)>/is', $content, $match)) {
            // 智能生成表单令牌隐藏域
            $replace[$match[0]] = $this->buildFormToken() . $match[0];
        }
    }

    // 允许用户自定义模板的字符串替换
    if (is_array(C('TMPL_PARSE_STRING')))
        $replace = array_merge($replace, C('TMPL_PARSE_STRING'));

    $content = str_replace(array_keys($replace), array_values($replace), $content);

    // 布局模板解析
    //$content = $this->layout($content,$charset,$contentType);
    // 输出模板文件
    if ($display)
        echo $content;
    else
        return $content;
}

#几种php实现定时任务的思路
1)、CronTab
2)、ignore_user_abort(false) false:关掉浏览器停止进程 true:关掉浏览器不停止进程

#实现在请求访问某个文件时，不必获得返回结果就继续往下执行程序
fsockopen()

#URl的几个部分
协议名（scheme），主机（host），端口号（port），文件路径（path），查询参数（query）

#php设置运行时间
set_time_limit()